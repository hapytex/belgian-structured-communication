-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | parsing, rendering and manipulating the structured communication of Belgian financial transactions.
--   
--   A package that exports a <a>StructuredCommunication</a> data type that
--   can render and manipulate structured communcation. The package also
--   has some parsers to parse structured communcation, and a quasi quoter
--   to define these at compile time.
@package belgian-structured-communication
@version 0.2.0.0


-- | Belgian companies often make use of <i>structured communication</i>
--   with a checksum. This package aims to provide a toolkit to parse,
--   render and manipulate <a>StructuredCommunication</a>.
module Finance.Belgium.StructuredCommunication

-- | A data type that stores three numbers: one with three digits
--   (<tt>000–999</tt>), four digits (<tt>0000–9999</tt>) and five digits
--   (<tt>00001–99997</tt>). The data constructor itself is not accessible,
--   since the <a>StructuredCommunication</a> could produce objects that
--   are out of the given ranges, or where the checksum is not valid. The
--   module thus aims to prevent parsing, changing, etc.
--   <a>StructuredCommunication</a> objects into an invalid state.
data StructuredCommunication
StructuredCommunication :: !Word16 -> !Word16 -> !Word32 -> StructuredCommunication

-- | Construct a <a>StructuredCommunication</a> object for the given three
--   integral values that form the three sequences of digits.
structuredCommunication :: (Integral i, Integral j, Integral k) => i -> j -> k -> Maybe StructuredCommunication

-- | Determining the <i>checksum</i>-part for the given
--   <a>StructuredCommunication</a>. This thus takes the last two digits,
--   or the third number modulo one hundred.
checksum :: StructuredCommunication -> Word32

-- | Determine the checksum based on the first ten digits. If the
--   <a>StructuredCommunication</a> is not valid, its <a>checksum</a> will
--   <i>not</i> match the result of the <a>determineChecksum</a>.
determineChecksum :: StructuredCommunication -> Word32

-- | Check if the checksum matches for the given
--   <a>StructuredCommunication</a>.
validChecksum :: StructuredCommunication -> Bool

-- | Convert the given <a>StructuredCommunication</a> to one where the
--   checksum is valid. If the checksum was already valid, it returns an
--   equivalent <a>StructuredCommunication</a>, this operation is thus
--   <i>idempotent</i>.
fixChecksum :: StructuredCommunication -> StructuredCommunication

-- | Convert the given <a>StructuredCommunication</a> to a <a>String</a>
--   that looks like a structured communication, so
--   <tt>+++000/0000/00097+++</tt>.
communicationToString :: StructuredCommunication -> String

-- | Convert the given <a>StructuredCommunication</a> to a <a>Text</a> that
--   looks like a structured communication, so
--   <tt>+++000/0000/00097+++</tt>.
communicationToText :: StructuredCommunication -> Text

-- | A <a>ParsecT</a> that parses a string into a
--   <a>StructuredCommunication</a>, the <a>StructuredCommunication</a> is
--   checked for its validity (checksum). The parser does <i>not</i> (per
--   se) ends with an <a>eof</a>.
communicationParser :: Stream s m Char => ParsecT s u m StructuredCommunication

-- | A <a>ParsecT</a> that parses a string into a
--   <a>StructuredCommunication</a>, the <a>StructuredCommunication</a> can
--   be invalid. The parser also does <i>not</i> (per se) ends with an
--   <a>eof</a>.
communicationParser' :: Stream s m Char => ParsecT s u m StructuredCommunication

-- | A <a>ParsecT</a> that parses a string into a
--   <a>StructuredCommunication</a>, the <a>StructuredCommunication</a> is
--   checked for its validity (checksum). The parser also checks that this
--   is the end of the stream.
communicationEParser :: Stream s m Char => ParsecT s u m StructuredCommunication

-- | A <a>ParsecT</a> that parses a string into a
--   <a>StructuredCommunication</a>, the <a>StructuredCommunication</a> can
--   be invalid. The parser also checks if this is the end of the stream.
communicationEParser' :: Stream s m Char => ParsecT s u m StructuredCommunication

-- | Parsing a stream into a <a>StructuredCommunication</a> that also
--   validates the checksum of the communication. The stream does not per
--   se needs to end with structured communcation.
parseCommunication :: Stream s Identity Char => s -> Either ParseError StructuredCommunication

-- | Parsing a stream into a <a>StructuredCommunication</a> that does
--   <i>noet</i> validate the checksum of the communication. The stream
--   does not per se needs to end with structured communcation.
parseCommunication' :: Stream s Identity Char => s -> Either ParseError StructuredCommunication

-- | Parsing a stream into a <a>StructuredCommunication</a> that also
--   validates the checksum of the communication. After the structured
--   communication, the stream needs to end.
parseCommunicationE :: Stream s Identity Char => s -> Either ParseError StructuredCommunication

-- | Parsing a stream into a <a>StructuredCommunication</a> that does
--   <i>noet</i> validate the checksum of the communication. After the
--   structured communication, the stream needs to end.
parseCommunicationE' :: Stream s Identity Char => s -> Either ParseError StructuredCommunication

-- | A <a>QuasiQuoter</a> that can parse a string into an expression or
--   pattern. It will thus convert <tt>+++000/000/00097+++</tt> into a
--   <a>StructuredCommunication</a> as expression or pattern.
beCommunication :: QuasiQuoter
instance GHC.Read.Read Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Classes.Ord Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Generics.Generic Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Classes.Eq Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Data.Data.Data Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Num.Num Finance.Belgium.StructuredCommunication.StructuredCommunication
instance System.Random.Random Finance.Belgium.StructuredCommunication.StructuredCommunication
instance System.Random.Internal.Uniform Finance.Belgium.StructuredCommunication.StructuredCommunication
instance System.Random.Internal.UniformRange Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Real.Real Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Real.Integral Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Show.Show Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Data.Hashable.Class.Hashable Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Test.QuickCheck.Arbitrary.Arbitrary Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Enum.Bounded Finance.Belgium.StructuredCommunication.StructuredCommunication
instance GHC.Enum.Enum Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Data.Binary.Class.Binary Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Data.Validity.Validity Finance.Belgium.StructuredCommunication.StructuredCommunication
instance Language.Haskell.TH.Syntax.Lift Finance.Belgium.StructuredCommunication.StructuredCommunication
